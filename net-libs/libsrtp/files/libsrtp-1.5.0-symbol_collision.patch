File libsrtp-1.5.0-orig/.ipc_in is a fifo while file libsrtp-1.5.0/.ipc_in is a fifo
File libsrtp-1.5.0-orig/.ipc_out is a fifo while file libsrtp-1.5.0/.ipc_out is a fifo
diff -urN libsrtp-1.5.0-orig/work/libsrtp-1.5.0/crypto/hash/hmac.c libsrtp-1.5.0/work/libsrtp-1.5.0/crypto/hash/hmac.c
--- libsrtp-1.5.0-orig/work/libsrtp-1.5.0/crypto/hash/hmac.c	2014-10-20 22:16:53.165059859 -0400
+++ libsrtp-1.5.0/work/libsrtp-1.5.0/crypto/hash/hmac.c	2014-10-20 22:20:56.561147079 -0400
@@ -141,10 +141,10 @@
   debug_print(mod_hmac, "ipad: %s", octet_string_hex_string(ipad, 64));
   
   /* initialize sha1 context */
-  sha1_init(&state->init_ctx);
+  crypto_sha1_init(&state->init_ctx);
 
   /* hash ipad ^ key */
-  sha1_update(&state->init_ctx, ipad, 64);
+  crypto_sha1_update(&state->init_ctx, ipad, 64);
   memcpy(&state->ctx, &state->init_ctx, sizeof(sha1_ctx_t)); 
 
   return err_status_ok;
@@ -165,7 +165,7 @@
 	      octet_string_hex_string(message, msg_octets));
   
   /* hash message into sha1 context */
-  sha1_update(&state->ctx, message, msg_octets);
+  crypto_sha1_update(&state->ctx, message, msg_octets);
 
   return err_status_ok;
 }
@@ -183,7 +183,7 @@
   
   /* hash message, copy output into H */
   hmac_update(state, (const uint8_t*)message, msg_octets);
-  sha1_final(&state->ctx, H);
+  crypto_sha1_final(&state->ctx, H);
 
   /*
    * note that we don't need to debug_print() the input, since the
@@ -193,16 +193,16 @@
 	      octet_string_hex_string((uint8_t *)H, 20));
 
   /* re-initialize hash context */
-  sha1_init(&state->ctx);
+  crypto_sha1_init(&state->ctx);
   
   /* hash opad ^ key  */
-  sha1_update(&state->ctx, (uint8_t *)state->opad, 64);
+  crypto_sha1_update(&state->ctx, (uint8_t *)state->opad, 64);
 
   /* hash the result of the inner hash */
-  sha1_update(&state->ctx, (uint8_t *)H, 20);
+  crypto_sha1_update(&state->ctx, (uint8_t *)H, 20);
   
   /* the result is returned in the array hash_value[] */
-  sha1_final(&state->ctx, hash_value);
+  crypto_sha1_final(&state->ctx, hash_value);
 
   /* copy hash_value to *result */
   for (i=0; i < tag_len; i++)    
diff -urN libsrtp-1.5.0-orig/work/libsrtp-1.5.0/crypto/hash/hmac_ossl.c libsrtp-1.5.0/work/libsrtp-1.5.0/crypto/hash/hmac_ossl.c
--- libsrtp-1.5.0-orig/work/libsrtp-1.5.0/crypto/hash/hmac_ossl.c	2014-10-20 22:16:53.165059859 -0400
+++ libsrtp-1.5.0/work/libsrtp-1.5.0/crypto/hash/hmac_ossl.c	2014-10-20 22:20:56.567146947 -0400
@@ -161,11 +161,11 @@
     debug_print(mod_hmac, "ipad: %s", octet_string_hex_string(ipad, 64));
 
     /* initialize sha1 context */
-    sha1_init(&state->init_ctx);
+    crypto_sha1_init(&state->init_ctx);
     state->init_ctx_initialized = 1;
 
     /* hash ipad ^ key */
-    sha1_update(&state->init_ctx, ipad, 64);
+    crypto_sha1_update(&state->init_ctx, ipad, 64);
     return (hmac_start(state));
 }
 
@@ -191,7 +191,7 @@
                 octet_string_hex_string(message, msg_octets));
 
     /* hash message into sha1 context */
-    sha1_update(&state->ctx, message, msg_octets);
+    crypto_sha1_update(&state->ctx, message, msg_octets);
 
     return err_status_ok;
 }
@@ -210,8 +210,8 @@
     }
 
     /* hash message, copy output into H */
-    sha1_update(&state->ctx, message, msg_octets);
-    sha1_final(&state->ctx, H);
+    crypto_sha1_update(&state->ctx, message, msg_octets);
+    crypto_sha1_final(&state->ctx, H);
 
     /*
      * note that we don't need to debug_print() the input, since the
@@ -221,16 +221,16 @@
                 octet_string_hex_string((uint8_t*)H, 20));
 
     /* re-initialize hash context */
-    sha1_init(&state->ctx);
+    crypto_sha1_init(&state->ctx);
 
     /* hash opad ^ key  */
-    sha1_update(&state->ctx, (uint8_t*)state->opad, 64);
+    crypto_sha1_update(&state->ctx, (uint8_t*)state->opad, 64);
 
     /* hash the result of the inner hash */
-    sha1_update(&state->ctx, (uint8_t*)H, 20);
+    crypto_sha1_update(&state->ctx, (uint8_t*)H, 20);
 
     /* the result is returned in the array hash_value[] */
-    sha1_final(&state->ctx, hash_value);
+    crypto_sha1_final(&state->ctx, hash_value);
 
     /* copy hash_value to *result */
     for (i = 0; i < tag_len; i++) {
diff -urN libsrtp-1.5.0-orig/work/libsrtp-1.5.0/crypto/hash/sha1.c libsrtp-1.5.0/work/libsrtp-1.5.0/crypto/hash/sha1.c
--- libsrtp-1.5.0-orig/work/libsrtp-1.5.0/crypto/hash/sha1.c	2014-10-20 22:16:53.165059859 -0400
+++ libsrtp-1.5.0/work/libsrtp-1.5.0/crypto/hash/sha1.c	2014-10-20 22:20:56.564147013 -0400
@@ -77,12 +77,12 @@
 uint32_t SHA_K3 = 0xCA62C1D6;   /* Kt for 60 <= t <= 79 */
 
 void
-sha1(const uint8_t *msg,  int octets_in_msg, uint32_t hash_value[5]) {
+crypto_sha1(const uint8_t *msg,  int octets_in_msg, uint32_t hash_value[5]) {
   sha1_ctx_t ctx;
 
-  sha1_init(&ctx);
-  sha1_update(&ctx, msg, octets_in_msg);
-  sha1_final(&ctx, hash_value);
+  crypto_sha1_init(&ctx);
+  crypto_sha1_update(&ctx, msg, octets_in_msg);
+  crypto_sha1_final(&ctx, hash_value);
 
 }
 
@@ -186,7 +186,7 @@
 }
 
 void
-sha1_init(sha1_ctx_t *ctx) {
+crypto_sha1_init(sha1_ctx_t *ctx) {
 
   /* initialize state vector */
   ctx->H[0] = 0x67452301;
@@ -204,7 +204,7 @@
 }
 
 void
-sha1_update(sha1_ctx_t *ctx, const uint8_t *msg, int octets_in_msg) {
+crypto_sha1_update(sha1_ctx_t *ctx, const uint8_t *msg, int octets_in_msg) {
   int i;
   uint8_t *buf = (uint8_t *)ctx->M;
 
@@ -247,12 +247,12 @@
 }
 
 /*
- * sha1_final(ctx, output) computes the result for ctx and copies it
+ * crypto_sha1_final(ctx, output) computes the result for ctx and copies it
  * into the twenty octets located at *output
  */
 
 void
-sha1_final(sha1_ctx_t *ctx, uint32_t *output) {
+crypto_sha1_final(sha1_ctx_t *ctx, uint32_t *output) {
   uint32_t A, B, C, D, E, TEMP;
   uint32_t W[80];  
   int i, t;
diff -urN libsrtp-1.5.0-orig/work/libsrtp-1.5.0/crypto/include/sha1.h libsrtp-1.5.0/work/libsrtp-1.5.0/crypto/include/sha1.h
--- libsrtp-1.5.0-orig/work/libsrtp-1.5.0/crypto/include/sha1.h	2014-10-20 22:16:53.166059878 -0400
+++ libsrtp-1.5.0/work/libsrtp-1.5.0/crypto/include/sha1.h	2014-10-20 22:20:56.558147144 -0400
@@ -55,12 +55,12 @@
 typedef EVP_MD_CTX sha1_ctx_t;
 
 /*
- * sha1_init(&ctx) initializes the SHA1 context ctx
+ * crypto_sha1_init(&ctx) initializes the SHA1 context ctx
  *
- * sha1_update(&ctx, msg, len) hashes the len octets starting at msg
+ * crypto_sha1_update(&ctx, msg, len) hashes the len octets starting at msg
  * into the SHA1 context
  *
- * sha1_final(&ctx, output) performs the final processing of the SHA1
+ * crypto_sha1_final(&ctx, output) performs the final processing of the SHA1
  * context and writes the result to the 20 octets at output
  *
  * Return values are ignored on the EVP functions since all three
@@ -68,18 +68,18 @@
  *
  */
 
-void inline sha1_init (sha1_ctx_t *ctx)
+void inline crypto_sha1_init (sha1_ctx_t *ctx)
 {
     EVP_MD_CTX_init(ctx);
     EVP_DigestInit(ctx, EVP_sha1());
 }
 
-void inline sha1_update (sha1_ctx_t *ctx, const uint8_t *M, int octets_in_msg)
+void inline crypto_sha1_update (sha1_ctx_t *ctx, const uint8_t *M, int octets_in_msg)
 {
     EVP_DigestUpdate(ctx, M, octets_in_msg);
 }
 
-void inline sha1_final (sha1_ctx_t *ctx, uint32_t *output)
+void inline crypto_sha1_final (sha1_ctx_t *ctx, uint32_t *output)
 {
     unsigned int len = 0;
 
@@ -103,27 +103,27 @@
  */
 
 void
-sha1(const uint8_t *message,  int octets_in_msg, uint32_t output[5]);
+crypto_sha1(const uint8_t *message,  int octets_in_msg, uint32_t output[5]);
 
 /*
- * sha1_init(&ctx) initializes the SHA1 context ctx
+ * crypto_sha1_init(&ctx) initializes the SHA1 context ctx
  * 
- * sha1_update(&ctx, msg, len) hashes the len octets starting at msg
+ * crypto_sha1_update(&ctx, msg, len) hashes the len octets starting at msg
  * into the SHA1 context
  * 
- * sha1_final(&ctx, output) performs the final processing of the SHA1
+ * crypto_sha1_final(&ctx, output) performs the final processing of the SHA1
  * context and writes the result to the 20 octets at output
  *
  */
 
 void
-sha1_init(sha1_ctx_t *ctx);
+crypto_sha1_init(sha1_ctx_t *ctx);
 
 void
-sha1_update(sha1_ctx_t *ctx, const uint8_t *M, int octets_in_msg);
+crypto_sha1_update(sha1_ctx_t *ctx, const uint8_t *M, int octets_in_msg);
 
 void
-sha1_final(sha1_ctx_t *ctx, uint32_t output[5]);
+crypto_sha1_final(sha1_ctx_t *ctx, uint32_t output[5]);
 
 /*
  * The sha1_core function is INTERNAL to SHA-1, but it is declared
diff -urN libsrtp-1.5.0-orig/work/libsrtp-1.5.0/crypto/test/sha1_driver.c libsrtp-1.5.0/work/libsrtp-1.5.0/crypto/test/sha1_driver.c
--- libsrtp-1.5.0-orig/work/libsrtp-1.5.0/crypto/test/sha1_driver.c	2014-10-20 22:16:53.167059897 -0400
+++ libsrtp-1.5.0/work/libsrtp-1.5.0/crypto/test/sha1_driver.c	2014-10-20 22:20:56.570146882 -0400
@@ -113,9 +113,9 @@
   if (test_case->data_len > MAX_HASH_DATA_LEN)
     return err_status_bad_param;
 
-  sha1_init(&ctx);
-  sha1_update(&ctx, test_case->data, test_case->data_len);
-  sha1_final(&ctx, hash_value);
+  crypto_sha1_init(&ctx);
+  crypto_sha1_update(&ctx, test_case->data, test_case->data_len);
+  crypto_sha1_final(&ctx, hash_value);
   if (0 == memcmp(test_case->hash, hash_value, 20)) {
 #if VERBOSE
     printf("PASSED: reference value: %s\n", 
